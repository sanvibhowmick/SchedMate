from lxml import etree
from models.timetable_schema import TimetableInput

# This utility is responsible for converting the validated Pydantic data model
# into the specific XML format required by the FET timetabling engine.
# Each section of the XML file is constructed methodically.

def generate_fet_xml(data: TimetableInput, file_path: str):
    """
    Generates a .fet XML file from the TimetableInput Pydantic model.

    Args:
        data: An instance of the TimetableInput model containing all scheduling information.
        file_path: The full path where the generated .fet file will be saved.
    """
    # Create the root element of the FET file with the required version attribute.
    root = etree.Element("fet", version="6.15.1")

    # --- Basic Information ---
    etree.SubElement(root, "Institution_Name").text = data.institution_name
    etree.SubElement(root, "Comments").text = "Automatically generated by SchedMate"

    # --- Time Structure: Days and Hours ---
    days_element = etree.SubElement(root, "Days_List")
    for day in data.days:
        etree.SubElement(days_element, "Name").text = day
    
    hours_element = etree.SubElement(root, "Hours_List")
    for hour in data.hours:
        etree.SubElement(hours_element, "Name").text = hour
        
    # --- Core Data Lists ---

    # Subjects List
    subjects_element = etree.SubElement(root, "Subjects_List")
    for subject in data.subjects:
        sub_elem = etree.SubElement(subjects_element, "Subject")
        etree.SubElement(sub_elem, "Name").text = subject.name

    # Teachers List
    teachers_element = etree.SubElement(root, "Teachers_List")
    for teacher in data.teachers:
        teacher_elem = etree.SubElement(teachers_element, "Teacher")
        etree.SubElement(teacher_elem, "Name").text = teacher.name

    # Student Groups List
    students_element = etree.SubElement(root, "Students_List")
    for group in data.student_groups:
        # In FET's structure, a "Year" contains "Groups" which contain "Subgroups".
        # For simplicity, we'll map our single group concept to all three levels.
        year_elem = etree.SubElement(students_element, "Year")
        etree.SubElement(year_elem, "Name").text = group.name
        group_elem = etree.SubElement(year_elem, "Group")
        etree.SubElement(group_elem, "Name").text = group.name
        subgroup_elem = etree.SubElement(group_elem, "Subgroup")
        etree.SubElement(subgroup_elem, "Name").text = group.name
        etree.SubElement(subgroup_elem, "Number_of_Students").text = str(group.num_students)

    # Rooms List
    rooms_element = etree.SubElement(root, "Rooms_List")
    for room in data.rooms:
        room_elem = etree.SubElement(rooms_element, "Room")
        etree.SubElement(room_elem, "Name").text = room.name
        etree.SubElement(room_elem, "Capacity").text = str(room.capacity)

    # Activities List (The most important part for scheduling)
    activities_element = etree.SubElement(root, "Activities_List")
    for i, activity in enumerate(data.activities):
        activity_elem = etree.SubElement(activities_element, "Activity")
        etree.SubElement(activity_elem, "Teacher").text = activity.teacher
        etree.SubElement(activity_elem, "Subject").text = activity.subject
        etree.SubElement(activity_elem, "Students").text = activity.student_group
        etree.SubElement(activity_elem, "Duration").text = str(activity.duration)
        etree.SubElement(activity_elem, "Total_Duration").text = str(activity.duration)
        etree.SubElement(activity_elem, "Id").text = str(i + 1) # FET requires a unique ID
        etree.SubElement(activity_elem, "Activity_Group_Id").text = "0" # Default value
        etree.SubElement(activity_elem, "Active").text = "true"
        etree.SubElement(activity_elem, "Comments").text = ""

    # --- Constraints Lists (Placeholders for future expansion) ---
    # These sections are where you would add more complex rules.
    etree.SubElement(root, "Time_Constraints_List")
    etree.SubElement(root, "Space_Constraints_List")

    # --- Finalizing the XML ---
    # Create an ElementTree object from the root element.
    tree = etree.ElementTree(root)
    
    # Write the complete XML tree to the specified file path.
    # `pretty_print=True` makes the output XML human-readable.
    tree.write(file_path, pretty_print=True, xml_declaration=True, encoding="UTF-8")
    
    print(f"Successfully generated FET input file at: {file_path}")

